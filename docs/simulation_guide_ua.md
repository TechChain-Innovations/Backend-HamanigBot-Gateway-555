# Посібник з використання симуляції свапів

## Вступ

Цей документ описує нову функціональність `simulate-swap`, додану до шлюзу. Цей інструмент був створений для вирішення специфічної задачі: визначення кінцевої ціни в пулі ліквідності після гіпотетичної угоди (свапу) без її реального виконання.

Це ключова функція для реалізації складних торгових стратегій, таких як "захист рівня ціни" (Peg Keeper), де боту потрібно точно розрахувати, який обсяг угоди необхідний для повернення ціни до заданого рівня.

## Як це працює: Технічна реалізація

Основне питання полягало в тому, як точно передбачити зміну ціни, особливо в пулах з концентрованою ліквідністю (CLMM), де ціна залежить від активних "тіків" ( ценових діапазонів).

Моя впевненість у коректності симуляції базується на тому, що я **не розраховую ціну вручну**. Замість цього, я використовую офіційні SDK від відповідних DEX (Uniswap та Raydium), які точно моделюють логіку, що відбувається он-чейн.

### 1. Симуляція для AMM (Uniswap V2, Raydium AMM/CPMM)

Для пулів з автоматичним маркет-мейкером (де працює формула `x * y = k`) логіка відносно проста:

1.  **Отримання поточних резервів:** Перед симуляцією я запитую поточні резерви токенів у пулі (назвемо їх `reserve_x` та `reserve_y`).
2.  **Симуляція обміну:** Використовуючи функцію `computeAmountOut` (або аналогічну) з SDK, я визначаю, скільки токена `Y` буде отримано (`amount_out`) за задану кількість токена `X` (`amount_in`).
3.  **Розрахунок нових резервів:** Після симуляції нові резерви пулу будуть:
    *   `new_reserve_x = reserve_x + amount_in`
    *   `new_reserve_y = reserve_y - amount_out`
4.  **Розрахунок кінцевої ціни:** Нова спотова ціна в пулі розраховується як співвідношення нових резервів: `finalPrice = new_reserve_y / new_reserve_x`.

Цей метод є точним для AMM-пулів, оскільки їхня математика повністю детермінована.

### 2. Симуляція для CLMM (Uniswap V3, Raydium CLMM)

Для пулів з концентрованою ліквідністю (CLMM) ручний розрахунок був би надзвичайно складним через наявність цінових "тіків". Тому я повністю покладаюся на можливості SDK:

*   **Uniswap V3:**
    1.  Під час симуляції свапу через Uniswap V3 SDK, результатом є об'єкт `Trade`.
    2.  Цей об'єкт, окрім іншого, містить `executionPrice` (ефективна ціна угоди), а також оновлений стан пулу після свапу, включаючи новий `sqrtRatioX96` (квадратний корінь з ціни, помножений на 2^96).
    3.  Поле **`finalPrice`** я розраховую саме з цього кінцевого `sqrtRatioX96`, що є точним відображенням ціни, яка встановиться в пулі, якби транзакція була виконана.

*   **Raydium CLMM:**
    1.  SDK Raydium ще зручніший в цьому плані. При виклику функції для симуляції свапу (`PoolUtils.computeAmountOut`), результат вже містить поле **`afterPrice`**.
    2.  Це і є готова кінцева ціна в пулі після симульованої угоди. Я беру це значення напряму з результату роботи SDK.

### 3. Симуляція для Агрегаторів (Jupiter)

Агрегатори, як Jupiter, працюють інакше. Вони шукають найкращий маршрут через десятки або сотні різних пулів (і AMM, і CLMM).

*   **Обмеження:** Через це, концепція "кінцевої ціни в одному пулі" до них незастосовна. API агрегаторів не повертає стан кожного окремого пулу, через який пройшла угода.
*   **Рішення:** Для `simulate-swap` на Jupiter, поле **`finalPrice`** буде дорівнювати полю `price` (ефективній ціні виконання всієї угоди). Це значення все ще корисне, оскільки воно показує, як змінюється середня ціна виконання при зміні обсягу, що дозволяє моделювати *загальний вплив на ринок*, а не на конкретний пул.

**Висновок:** В усіх випадках я використовую офіційні інструменти від розробників протоколів, які створені для точного моделювання он-чейн логіки. Це гарантує, що розрахована `finalPrice` буде максимально близькою до реальної ціни, яка встановилася б у пулі.

## Як користуватися

Було додано нові ендпоінти `/simulate-swap` для AMM та CLMM пулів Uniswap, Raydium, а також для роутера Jupiter.

### Доступні ендпоінти

*   `GET /connectors/uniswap/amm/simulate-swap`
*   `GET /connectors/uniswap/clmm/simulate-swap`
*   `GET /connectors/raydium/amm/simulate-swap`
*   `GET /connectors/raydium/clmm/simulate-swap`
*   `GET /connectors/jupiter/router/simulate-swap`

### Параметри запиту

Ендпоінти приймають ті ж параметри, що і `quote-swap`:

*   `network` (string): Назва мережі (напр. `mainnet`, `mainnet-beta`).
*   `poolAddress` (string): Адреса пулу (опціонально, якщо вказані `baseToken` та `quoteToken`, не використовується для Jupiter).
*   `baseToken` (string): Символ або адреса базового токена.
*   `quoteToken` (string): Символ або адреса токена котирування.
*   `amount` (number): Кількість **базового токена** для обміну.
*   `side` (string): Напрямок угоди - `BUY` або `SELL`.

**Приклад запиту (Jupiter):**
```bash
curl -X GET "http://localhost:15888/connectors/jupiter/router/simulate-swap?network=mainnet-beta&baseToken=SOL&quoteToken=USDC&amount=10&side=SELL"
```

### Формат відповіді

Відповідь схожа на `quote-swap`, але містить додаткове поле `finalPrice`.

**Приклад відповіді (для Raydium/Uniswap):**
```json
{
  "poolAddress": "58oQChx4yWmvKdwLLZzBi4ChoCc2fqCUWBkwMihLYQo2",
  "tokenIn": "So11111111111111111111111111111111111111112",
  "tokenOut": "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
  "amountIn": 10,
  "amountOut": 1450.5,
  "price": 145.05,
  "priceImpactPct": 0.015,
  "finalPrice": 145.03
}
```

*   `price`: Середня ціна виконання цієї конкретної угоди.
*   **`finalPrice`**: **Спотова ціна в пулі після завершення цієї угоди.** (Для Jupiter це значення буде дорівнювати `price`).

### Використання для стратегії "захисту рівня"

З новим ендпоінтом ви можете реалізувати вашу стратегію, наприклад, за допомогою бінарного пошуку:

1.  **Початкові дані:**
    *   `targetPrice` = 150
    *   `currentPrice` = 145
    *   Потрібно знайти `amountIn` (скільки USDC купити), щоб `finalPrice` стала `150`.

2.  **Алгоритм:**
    *   Встановіть мінімальну та максимальну межі для пошуку суми (`minAmount`, `maxAmount`).
    *   В циклі робіть запит до `/simulate-swap`, використовуючи середнє значення між `minAmount` та `maxAmount`.
    *   Якщо `finalPrice` з відповіді більша за `targetPrice`, зменшуйте `maxAmount`.
    *   Якщо `finalPrice` менша, збільшуйте `minAmount`.
    *   Повторюйте, доки не знайдете `amountIn`, що дає `finalPrice` з потрібною вам точністю.

Таким чином, реалізований функціонал повністю задовольняє вашу потребу в симуляції для побудови складних торгових логік.
